# -*- coding: utf-8 -*-
"""A.E.G.i.S.py.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13fJv0y6cXannb_KlykhtcCUvMJEe_P1y
"""

import numpy as np
import matplotlib.pyplot as plt

# ==========================================
# 1. Filtered PID Controller (Strong Rival)
# ==========================================
class FilteredPIDController:
    """
    Standard PID with Low-Pass Filter on D-term
    (Realistic Industrial PID - A worthy opponent)
    """
    def __init__(self, kp, ki, kd, tau_f=0.1, out_min=0.0, out_max=100.0, dt=1.0):
        self.kp = kp
        self.ki = ki
        self.kd = kd
        self.tau_f = tau_f # Filter Time Constant
        self.out_min = out_min
        self.out_max = out_max
        self.dt = dt

        self.integral = 0.0
        self.prev_error = 0.0
        self.d_term_filtered = 0.0
        # For derivative-on-measurement (to reduce derivative kick)
        self.prev_pv = None

    def update(self, sp, pv):
        error = sp - pv

        # P Term
        p_term = self.kp * error

        # I Term (with Anti-windup simple clipping)
        self.integral += error * self.dt
        self.integral = np.clip(self.integral, -100, 100)
        i_term = self.ki * self.integral

        # D Term (Filtered) -- derivative on pv to avoid setpoint kick
        if self.prev_pv is None:
            d_raw = 0.0
        else:
            # derivative of pv -> -pv_dot contributes to controller
            d_raw = -(pv - self.prev_pv) / self.dt
        self.prev_pv = pv

        # LPF: alpha depends on tau_f
        if self.tau_f > 0:
            alpha = self.tau_f / (self.tau_f + self.dt)
            self.d_term_filtered = alpha * self.d_term_filtered + (1 - alpha) * d_raw
        else:
            self.d_term_filtered = d_raw

        d_term = self.kd * self.d_term_filtered

        output = p_term + i_term + d_term
        output = np.clip(output, self.out_min, self.out_max)

        self.prev_error = error
        return output

# ==========================================
# 2. AEGIS (User's Tuned Version)
# ==========================================
class ZGatedPIController:
    """
    Improved Version: Adaptive PI-Controller
    Configured with User's parameters (High Base Gain, Low Gamma)
    """
    def __init__(self, base_gain, ki, gain_max=10.0, target_noise=0.5,
                 p=1.5, gamma=0.01, anchor_decay=0.01, dt=1.0):
        self.base_gain = base_gain
        self.current_gain = base_gain # Starts at base_gain
        self.ki = ki
        self.gain_max = gain_max

        self.target_noise = target_noise
        self.p = p
        self.gamma = gamma
        self.anchor_decay = anchor_decay
        self.dt = dt

        self.m_error = 0.0
        self.ep_energy = 0.0
        self.integral = 0.0
        self.beta = 0.9

    def update(self, sp, pv):
        error = sp - pv

        # --- Z-Gating (Adaptive Logic) ---
        self.m_error = self.beta * self.m_error + (1 - self.beta) * error
        delta = error - self.m_error
        instability = abs(delta) ** self.p
        self.ep_energy = self.beta * self.ep_energy + (1 - self.beta) * instability
        sigma = (self.ep_energy + 1e-8) ** (1.0 / self.p)
        r = sigma / (self.target_noise + 1e-6)

        # Gain Dynamics
        # NOTE: include dt so adaptation scales with sampling period
        da = -self.gamma * (r - 1.0) * self.current_gain
        da -= self.anchor_decay * (self.current_gain - self.base_gain)
        da *= self.dt

        self.current_gain += da
        # Clamped between 0.1 and gain_max
        self.current_gain = np.clip(self.current_gain, 0.1, self.gain_max)

        # --- PI Control ---
        p_term = self.current_gain * error

        self.integral += error * self.dt
        # Anti-windup scaled by Ki (simple clipping)
        limit = 100.0 / (self.ki + 1e-6)
        self.integral = np.clip(self.integral, -limit, limit)
        i_term = self.ki * self.integral

        output = p_term + i_term
        output = np.clip(output, 0.0, 100.0)

        return output, self.current_gain

# ==========================================
# 3. Environment (With Severe Disturbance)
# ==========================================
class IndustrialHeater:
    def __init__(self, tau=20.0, gain=2.0, dt=1.0, initial_temp=20.0):
        self.tau = tau
        self.gain = gain
        self.dt = dt
        self.temp = initial_temp

    def step(self, u_input, external_noise=0.0, load_disturbance=0.0):
        # process: tau*y' + y = K*u + Disturbance
        d_temp = (self.gain * u_input - self.temp + load_disturbance) / self.tau * self.dt
        self.temp += d_temp
        return self.temp + external_noise

# ==========================================
# 4. Main Battle Loop (parameterized)
# ==========================================
def run_ultimate_battle(
    duration=500,
    seed=42,
    show_plot=True,
    save_fig=None,
    # Controller parameters (kept default as before)
    pid_params=dict(kp=3.0, ki=0.15, kd=5.0, tau_f=2.0),
    aegis_params=dict(base_gain=4.0, ki=0.2, gamma=0.008, target_noise=0.8, gain_max=10.0),
    noise_std=0.8,
    disturbance_profile=None,
    sp_schedule=None,
    verbose=True
):
    """
    Runs one simulation, returns metrics and history.
    If show_plot is True, displays plots. If save_fig is provided, saves figure to that path.
    """
    np.random.seed(seed)

    # Default setpoint schedule if not provided
    if sp_schedule is None:
        sp_schedule = [50] * 150 + [80] * (duration - 150)

    # Noise Profile
    noise_profile = np.random.normal(0, noise_std, size=duration)

    # Disturbance profile default (the -30 cold draft between t=300..450)
    if disturbance_profile is None:
        dist_profile = np.zeros(duration)
        # ensure within duration
        start = 300
        end = min(450, duration)
        if start < duration:
            dist_profile[start:end] = -30.0
    else:
        dist_profile = disturbance_profile

    # Controllers Setup
    pid = FilteredPIDController(dt=1.0, **pid_params)
    aegis = ZGatedPIController(dt=1.0, **aegis_params)

    # Simulation Objects
    proc_pid = IndustrialHeater()
    proc_aegis = IndustrialHeater()

    history = {
        'pid': [], 'aegis': [], 'gain_log': [],
        'mv_pid': [], 'mv_aegis': [],
        'sp': sp_schedule, 'time': list(range(duration))
    }

    mv_pid, mv_aegis = 0.0, 0.0

    if verbose:
        print("‚öîÔ∏è  STARTING ULTIMATE CONTROL BATTLE ‚öîÔ∏è")
        print(f"Strategy: AEGIS base_gain={aegis.base_gain}, gain_max={aegis.gain_max} vs Filtered PID")
        print(f"Event: -30¬∞C Cold Draft between t=300 and t=450 (if within duration)")

    for t in range(duration):
        sp = sp_schedule[t]
        noise = noise_profile[t]
        dist = dist_profile[t]

        # PID Step
        pv_pid = proc_pid.step(mv_pid, noise, dist)
        mv_pid = pid.update(sp, pv_pid)

        # AEGIS Step
        pv_aegis = proc_aegis.step(mv_aegis, noise, dist)
        mv_aegis, current_gain = aegis.update(sp, pv_aegis)

        history['pid'].append(pv_pid)
        history['aegis'].append(pv_aegis)
        history['gain_log'].append(current_gain)
        history['mv_pid'].append(mv_pid)
        history['mv_aegis'].append(mv_aegis)

    # Metrics (IAE)
    def get_iae(pv_data):
        return np.sum(np.abs(np.array(sp_schedule) - np.array(pv_data)))

    iae_pid = get_iae(history['pid'])
    iae_aegis = get_iae(history['aegis'])

    # Control energy (sum of squared mv)
    energy_pid = np.sum(np.array(history['mv_pid'])**2)
    energy_aegis = np.sum(np.array(history['mv_aegis'])**2)

    improvement = (1 - iae_aegis/iae_pid)*100 if iae_pid != 0 else float('nan')

    # Gain stats
    gain_arr = np.array(history['gain_log'])
    gain_stats = {
        'gain_min': float(np.min(gain_arr)),
        'gain_mean': float(np.mean(gain_arr)),
        'gain_max': float(np.max(gain_arr))
    }

    if verbose:
        print("-" * 60)
        print(f"{'Metric':<15} | {'Filtered PID':<15} | {'AEGIS (Yours)':<15}")
        print("-" * 60)
        print(f"{'IAE (Error)':<15} | {iae_pid:<15.1f} | {iae_aegis:<15.1f}")
        print(f"{'Control Energy':<15} | {energy_pid:<15.1f} | {energy_aegis:<15.1f}")
        print(f"{'Improvement':<15} | {'-':<15} | {improvement:+.1f}%")
        print("-" * 60)
        print("AEGIS Gain Stats: min/mean/max = "
              f"{gain_stats['gain_min']:.3f} / {gain_stats['gain_mean']:.3f} / {gain_stats['gain_max']:.3f}")

    # Visualization
    if show_plot:
        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 10), sharex=True)

        # Plot 1: PV Comparison (The Race)
        ax1.plot(history['time'], sp_schedule, 'k--', label='Set Point', alpha=0.6)
        ax1.plot(history['time'], history['pid'], 'r-', label='Filtered PID', alpha=0.6)
        ax1.plot(history['time'], history['aegis'], 'g-', label='AEGIS (Adaptive)', linewidth=2)

        # Highlight Disturbance
        # find disturbance windows
        if np.any(np.array(dist_profile) != 0):
            # naive single span from first to last non-zero
            nz = np.nonzero(np.array(dist_profile))[0]
            if nz.size > 0:
                ax1.axvspan(int(nz[0]), int(nz[-1]), color='blue', alpha=0.1, label='Disturbance')

        ax1.set_title("1. Robustness Test: Can it survive the storm?")
        ax1.set_ylabel("Temperature (¬∞C)")
        ax1.legend(loc='lower right')
        ax1.grid(True, alpha=0.3)

        # Plot 2: AEGIS Gain (The Strategy)
        ax2.plot(history['time'], history['gain_log'], 'b-', label='AEGIS Gain (Kp)')
        ax2.axhline(aegis.gain_max, color='r', linestyle=':', label='Max Limit')
        ax2.set_title("2. AEGIS Internal Gain State")
        ax2.set_ylabel("Gain Value")
        ax2.set_xlabel("Time (s)")
        ax2.legend()
        ax2.grid(True, alpha=0.3)

        plt.tight_layout()
        if save_fig:
            plt.savefig(save_fig, bbox_inches='tight')
            if verbose:
                print(f"Figure saved to {save_fig}")
        plt.show()
    else:
        if save_fig and verbose:
            print("Plot saving requested but show_plot=False; to save without display, pass show_plot=False and save_fig path (not typical on headless without backend).")

    results = {
        'iae_pid': float(iae_pid),
        'iae_aegis': float(iae_aegis),
        'improvement_pct': float(improvement),
        'energy_pid': float(energy_pid),
        'energy_aegis': float(energy_aegis),
        'gain_stats': gain_stats,
        'history': history
    }

    return results

if __name__ == "__main__":
    # Default run for interactive use
    run_ultimate_battle(show_plot=True, save_fig=None, verbose=True)

import numpy as np
import matplotlib.pyplot as plt

# ==========================================
# 1. Filtered PID Controller (Strong Rival)
# ==========================================
class FilteredPIDController:
    """
    Standard PID with Low-Pass Filter on D-term
    """
    def __init__(self, kp, ki, kd, tau_f=0.1, out_min=0.0, out_max=100.0, dt=1.0):
        self.kp = kp
        self.ki = ki
        self.kd = kd
        self.tau_f = tau_f
        self.out_min = out_min
        self.out_max = out_max
        self.dt = dt

        self.integral = 0.0
        self.prev_error = 0.0
        self.d_term_filtered = 0.0
        self.prev_pv = None

    def update(self, sp, pv):
        error = sp - pv
        p_term = self.kp * error
        self.integral += error * self.dt
        self.integral = np.clip(self.integral, -100, 100)
        i_term = self.ki * self.integral

        if self.prev_pv is None:
            d_raw = 0.0
        else:
            d_raw = -(pv - self.prev_pv) / self.dt
        self.prev_pv = pv

        if self.tau_f > 0:
            alpha = self.tau_f / (self.tau_f + self.dt)
            self.d_term_filtered = alpha * self.d_term_filtered + (1 - alpha) * d_raw
        else:
            self.d_term_filtered = d_raw

        d_term = self.kd * self.d_term_filtered
        output = p_term + i_term + d_term
        output = np.clip(output, self.out_min, self.out_max)
        self.prev_error = error
        return output

# ==========================================
# 2. AEGIS (User's Tuned Version)
# ==========================================
class ZGatedPIController:
    """
    Improved Version: Adaptive PI-Controller
    """
    def __init__(self, base_gain, ki, gain_max=10.0, target_noise=0.5,
                 p=1.5, gamma=0.01, anchor_decay=0.01, dt=1.0):
        self.base_gain = base_gain
        self.current_gain = base_gain
        self.ki = ki
        self.gain_max = gain_max

        self.target_noise = target_noise
        self.p = p
        self.gamma = gamma
        self.anchor_decay = anchor_decay
        self.dt = dt

        self.m_error = 0.0
        self.ep_energy = 0.0
        self.integral = 0.0
        self.beta = 0.9

    def update(self, sp, pv):
        error = sp - pv

        # --- Z-Gating (Adaptive Logic) ---
        self.m_error = self.beta * self.m_error + (1 - self.beta) * error
        delta = error - self.m_error
        instability = abs(delta) ** self.p
        self.ep_energy = self.beta * self.ep_energy + (1 - self.beta) * instability
        sigma = (self.ep_energy + 1e-8) ** (1.0 / self.p)
        r = sigma / (self.target_noise + 1e-6)

        # Gain Dynamics
        da = -self.gamma * (r - 1.0) * self.current_gain
        da -= self.anchor_decay * (self.current_gain - self.base_gain)
        da *= self.dt

        self.current_gain += da
        self.current_gain = np.clip(self.current_gain, 0.1, self.gain_max)

        # --- PI Control ---
        p_term = self.current_gain * error

        self.integral += error * self.dt
        limit = 100.0 / (self.ki + 1e-6)
        self.integral = np.clip(self.integral, -limit, limit)
        i_term = self.ki * self.integral

        output = p_term + i_term
        output = np.clip(output, 0.0, 100.0)

        return output, self.current_gain

# ==========================================
# 3. Environment (With Severe Disturbance)
# ==========================================
class IndustrialHeater:
    def __init__(self, tau=20.0, gain=2.0, dt=1.0, initial_temp=20.0):
        self.tau = tau
        self.gain = gain
        self.dt = dt
        self.temp = initial_temp

    def step(self, u_input, external_noise=0.0, load_disturbance=0.0):
        d_temp = (self.gain * u_input - self.temp + load_disturbance) / self.tau * self.dt
        self.temp += d_temp
        return self.temp + external_noise

# ==========================================
# 4. Main Battle Loop (parameterized)
# ==========================================
def run_ultimate_battle(
    duration=500,
    seed=42,
    show_plot=True,
    save_fig=None,
    # Controller parameters
    pid_params=dict(kp=3.0, ki=0.15, kd=5.0, tau_f=2.0),

    # [ÏàòÏ†ïÎêú Î∂ÄÎ∂Ñ: Eco-Mode Parameter Tuning]
    # Íµ¨Ï°∞ Î≥ÄÍ≤Ω ÏóÜÏù¥ ÌååÎùºÎØ∏ÌÑ∞ÎßåÏúºÎ°ú ÏóêÎÑàÏßÄÎ•º Ï§ÑÏù¥Îäî ÏµúÏ†ÅÍ∞í
    aegis_params=dict(
        base_gain=3.5,     # Í∏∞Ï°¥ 4.0 -> 3.5 (ÌèâÏÉÅÏãú Ìûò ÎπºÍ∏∞)
        ki=0.15,           # Í∏∞Ï°¥ 0.3 -> 0.15 (Í∏âÎ∞úÏßÑ Î∞©ÏßÄ, ÏóêÎÑàÏßÄ Ï†àÏïΩÏùò ÌïµÏã¨)
        gamma=0.005,       # Í∏∞Ï°¥ 0.008 -> 0.005 (Îçî Ïã†Ï§ëÌïòÍ≤å Í≤åÏù∏ Î≥ÄÍ≤Ω)
        target_noise=0.8,
        gain_max=8.0       # Í∏∞Ï°¥ 15.0 -> 8.0 (ÏµúÎåÄ ÌååÏõå Ï†úÌïú)
    ),

    noise_std=0.8,
    disturbance_profile=None,
    sp_schedule=None,
    verbose=True
):
    np.random.seed(seed)
    if sp_schedule is None:
        sp_schedule = [50] * 150 + [80] * (duration - 150)
    noise_profile = np.random.normal(0, noise_std, size=duration)

    if disturbance_profile is None:
        dist_profile = np.zeros(duration)
        start = 300
        end = min(450, duration)
        if start < duration:
            dist_profile[start:end] = -30.0
    else:
        dist_profile = disturbance_profile

    pid = FilteredPIDController(dt=1.0, **pid_params)
    aegis = ZGatedPIController(dt=1.0, **aegis_params)
    proc_pid = IndustrialHeater()
    proc_aegis = IndustrialHeater()

    history = {
        'pid': [], 'aegis': [], 'gain_log': [],
        'mv_pid': [], 'mv_aegis': [],
        'sp': sp_schedule, 'time': list(range(duration))
    }

    mv_pid, mv_aegis = 0.0, 0.0

    if verbose:
        print("‚öîÔ∏è  STARTING ULTIMATE CONTROL BATTLE (Eco-Tuning) ‚öîÔ∏è")
        print(f"Strategy: AEGIS base_gain={aegis.base_gain}, gain_max={aegis.gain_max} vs Filtered PID")

    for t in range(duration):
        sp = sp_schedule[t]
        noise = noise_profile[t]
        dist = dist_profile[t]

        pv_pid = proc_pid.step(mv_pid, noise, dist)
        mv_pid = pid.update(sp, pv_pid)

        pv_aegis = proc_aegis.step(mv_aegis, noise, dist)
        mv_aegis, current_gain = aegis.update(sp, pv_aegis)

        history['pid'].append(pv_pid)
        history['aegis'].append(pv_aegis)
        history['gain_log'].append(current_gain)
        history['mv_pid'].append(mv_pid)
        history['mv_aegis'].append(mv_aegis)

    def get_iae(pv_data):
        return np.sum(np.abs(np.array(sp_schedule) - np.array(pv_data)))

    iae_pid = get_iae(history['pid'])
    iae_aegis = get_iae(history['aegis'])
    energy_pid = np.sum(np.array(history['mv_pid'])**2)
    energy_aegis = np.sum(np.array(history['mv_aegis'])**2)
    improvement = (1 - iae_aegis/iae_pid)*100 if iae_pid != 0 else float('nan')

    gain_arr = np.array(history['gain_log'])
    gain_stats = {
        'gain_min': float(np.min(gain_arr)),
        'gain_mean': float(np.mean(gain_arr)),
        'gain_max': float(np.max(gain_arr))
    }

    if verbose:
        print("-" * 60)
        print(f"{'Metric':<15} | {'Filtered PID':<15} | {'AEGIS (Yours)':<15}")
        print("-" * 60)
        print(f"{'IAE (Error)':<15} | {iae_pid:<15.1f} | {iae_aegis:<15.1f}")
        print(f"{'Control Energy':<15} | {energy_pid:<15.1f} | {energy_aegis:<15.1f}")
        print(f"{'Improvement':<15} | {'-':<15} | {improvement:+.1f}%")
        print("-" * 60)

    if show_plot:
        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 10), sharex=True)
        ax1.plot(history['time'], sp_schedule, 'k--', label='Set Point', alpha=0.6)
        ax1.plot(history['time'], history['pid'], 'r-', label='Filtered PID', alpha=0.6)
        ax1.plot(history['time'], history['aegis'], 'g-', label='AEGIS (Eco-Mode)', linewidth=2)

        if np.any(np.array(dist_profile) != 0):
            nz = np.nonzero(np.array(dist_profile))[0]
            if nz.size > 0:
                ax1.axvspan(int(nz[0]), int(nz[-1]), color='blue', alpha=0.1, label='Disturbance')

        ax1.set_title("1. Robustness Test (Eco Tuning)")
        ax1.set_ylabel("Temperature (¬∞C)")
        ax1.legend(loc='lower right')
        ax1.grid(True, alpha=0.3)

        ax2.plot(history['time'], history['gain_log'], 'b-', label='AEGIS Gain (Kp)')
        ax2.axhline(aegis.gain_max, color='r', linestyle=':', label='Max Limit')
        ax2.set_title("2. AEGIS Internal Gain State")
        ax2.set_ylabel("Gain Value")
        ax2.legend()
        ax2.grid(True, alpha=0.3)
        plt.tight_layout()
        if save_fig: plt.savefig(save_fig)
        plt.show()

    return {'iae_pid': iae_pid, 'iae_aegis': iae_aegis, 'energy_pid': energy_pid, 'energy_aegis': energy_aegis}

if __name__ == "__main__":
    run_ultimate_battle(show_plot=True)

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

!pip install scipy
from scipy import stats

# ==========================================
# 1. Controller & Environment Classes (Í∏∞Ï°¥ Î°úÏßÅ Ïú†ÏßÄ)
# ==========================================
class FilteredPIDController:
    def __init__(self, kp, ki, kd, tau_f=0.1, out_min=0.0, out_max=100.0, dt=1.0):
        self.kp = kp
        self.ki = ki
        self.kd = kd
        self.tau_f = tau_f
        self.out_min = out_min
        self.out_max = out_max
        self.dt = dt
        self.integral = 0.0
        self.prev_error = 0.0
        self.d_term_filtered = 0.0
        self.prev_pv = None

    def update(self, sp, pv):
        error = sp - pv
        p_term = self.kp * error
        self.integral += error * self.dt
        self.integral = np.clip(self.integral, -100, 100)
        i_term = self.ki * self.integral

        if self.prev_pv is None: d_raw = 0.0
        else: d_raw = -(pv - self.prev_pv) / self.dt
        self.prev_pv = pv

        if self.tau_f > 0:
            alpha = self.tau_f / (self.tau_f + self.dt)
            self.d_term_filtered = alpha * self.d_term_filtered + (1 - alpha) * d_raw
        else:
            self.d_term_filtered = d_raw

        d_term = self.kd * self.d_term_filtered
        output = np.clip(p_term + i_term + d_term, self.out_min, self.out_max)
        return output

class ZGatedPIController:
    def __init__(self, base_gain, ki, gain_max=10.0, target_noise=0.5,
                 p=1.5, gamma=0.01, anchor_decay=0.01, dt=1.0):
        self.base_gain = base_gain
        self.current_gain = base_gain
        self.ki = ki
        self.gain_max = gain_max
        self.target_noise = target_noise
        self.p = p
        self.gamma = gamma
        self.anchor_decay = anchor_decay
        self.dt = dt
        self.m_error = 0.0
        self.ep_energy = 0.0
        self.integral = 0.0
        self.beta = 0.9

    def update(self, sp, pv):
        error = sp - pv
        self.m_error = self.beta * self.m_error + (1 - self.beta) * error
        delta = error - self.m_error
        instability = abs(delta) ** self.p
        self.ep_energy = self.beta * self.ep_energy + (1 - self.beta) * instability
        sigma = (self.ep_energy + 1e-8) ** (1.0 / self.p)
        r = sigma / (self.target_noise + 1e-6)

        da = -self.gamma * (r - 1.0) * self.current_gain
        da -= self.anchor_decay * (self.current_gain - self.base_gain)
        da *= self.dt
        self.current_gain = np.clip(self.current_gain + da, 0.1, self.gain_max)

        p_term = self.current_gain * error
        self.integral += error * self.dt
        limit = 100.0 / (self.ki + 1e-6)
        self.integral = np.clip(self.integral, -limit, limit)
        i_term = self.ki * self.integral

        output = np.clip(p_term + i_term, 0.0, 100.0)
        return output, self.current_gain

class IndustrialHeater:
    def __init__(self, tau=20.0, gain=2.0, dt=1.0, initial_temp=20.0):
        self.tau = tau
        self.gain = gain
        self.dt = dt
        self.temp = initial_temp
    def step(self, u_input, external_noise=0.0, load_disturbance=0.0):
        d_temp = (self.gain * u_input - self.temp + load_disturbance) / self.tau * self.dt
        self.temp += d_temp
        return self.temp + external_noise

# ==========================================
# 2. Data Generation Loop for ANOVA
# ==========================================
def generate_anova_dataset(n_samples=30, duration=500):
    """
    Runs the simulation n_samples times with different random seeds.
    Returns a DataFrame suitable for ANOVA (cols: Run_ID, Controller, IAE).
    """
    print(f"üöÄ Generating data for ANOVA (N={n_samples} trials)...")

    # Parameters (Fixed for fairness)
    pid_params = dict(kp=3.0, ki=0.15, kd=5.0, tau_f=2.0)
    aegis_params = dict(base_gain=5.0, ki=0.4, gamma=0.008, target_noise=0.8, gain_max=15.0)
    sp_schedule = [50] * 150 + [80] * (duration - 150)

    data_records = []

    for i in range(n_samples):
        # 1. Random Seed Setup (Distinct for each run)
        seed = 42 + i
        np.random.seed(seed)

        # 2. Noise & Disturbance
        noise_profile = np.random.normal(0, 0.8, size=duration)
        dist_profile = np.zeros(duration)
        dist_profile[300:450] = -30.0 # Cold draft event

        # 3. Instantiate Controllers & Process
        pid = FilteredPIDController(dt=1.0, **pid_params)
        aegis = ZGatedPIController(dt=1.0, **aegis_params)
        proc_pid = IndustrialHeater()
        proc_aegis = IndustrialHeater()

        # 4. Run Simulation
        mv_pid, mv_aegis = 0.0, 0.0
        hist_pid_pv = []
        hist_aegis_pv = []

        for t in range(duration):
            sp = sp_schedule[t]
            noise = noise_profile[t]
            dist = dist_profile[t]

            # PID Step
            pv_pid = proc_pid.step(mv_pid, noise, dist)
            mv_pid = pid.update(sp, pv_pid)
            hist_pid_pv.append(pv_pid)

            # AEGIS Step
            pv_aegis = proc_aegis.step(mv_aegis, noise, dist)
            mv_aegis, _ = aegis.update(sp, pv_aegis)
            hist_aegis_pv.append(pv_aegis)

        # 5. Calculate Metric (IAE)
        iae_pid = np.sum(np.abs(np.array(sp_schedule) - np.array(hist_pid_pv)))
        iae_aegis = np.sum(np.abs(np.array(sp_schedule) - np.array(hist_aegis_pv)))

        # 6. Append to Dataset (Long Format for ANOVA)
        data_records.append({'Run_ID': i, 'Controller': 'PID', 'IAE': iae_pid})
        data_records.append({'Run_ID': i, 'Controller': 'AEGIS', 'IAE': iae_aegis})

    # Create DataFrame
    df = pd.DataFrame(data_records)
    return df

# ==========================================
# 3. Run ANOVA & Visualize
# ==========================================
def main():
    # 1. Generate Data (N=30 is standard for small sample stats)
    df = generate_anova_dataset(n_samples=30)

    # 2. Save to CSV (This is what you need for SPSS/Excel/R)
    filename = "anova_dataset.csv"
    df.to_csv(filename, index=False)
    print(f"\n‚úÖ Dataset saved to '{filename}'")
    print(df.head(6)) # Show first few rows

    # 3. Perform One-Way ANOVA (using scipy)
    group_pid = df[df['Controller'] == 'PID']['IAE']
    group_aegis = df[df['Controller'] == 'AEGIS']['IAE']

    f_stat, p_val = stats.f_oneway(group_pid, group_aegis)

    print("\n" + "="*40)
    print("      ONE-WAY ANOVA RESULTS")
    print("="*40)
    print(f"F-Statistic : {f_stat:.4f}")
    print(f"P-Value     : {p_val:.4e}")
    print("-" * 40)

    if p_val < 0.05:
        print(">> Í≤∞Î°†: P < 0.05 Ïù¥ÎØÄÎ°ú ÌÜµÍ≥ÑÏ†ÅÏúºÎ°ú Ïú†ÏùòÎØ∏Ìïú Ï∞®Ïù¥Í∞Ä ÏûàÏùå (H1 Ï±ÑÌÉù)")
        print(f">> AEGISÍ∞Ä PIDÏôÄ ÏÑ±Îä•Ïù¥ 'ÌôïÏã§Ìûà Îã§Î•¥Îã§'Îäî Í≤ÉÏù¥ Ï¶ùÎ™ÖÎê®.")
    else:
        print(">> Í≤∞Î°†: ÌÜµÍ≥ÑÏ†ÅÏúºÎ°ú Ïú†ÏùòÎØ∏Ìïú Ï∞®Ïù¥Í∞Ä ÏóÜÏùå (H0 Í∏∞Í∞Å Ïã§Ìå®)")

    # 4. Visualization (Boxplot for ANOVA)
    plt.figure(figsize=(8, 6))
    df.boxplot(column='IAE', by='Controller', grid=True, figsize=(8,6))
    plt.title('IAE Distribution: PID vs AEGIS (N=30 Runs)')
    plt.suptitle('') # Remove default super title
    plt.ylabel('IAE (Lower is Better)')
    plt.xlabel('Controller Type')

    # Save plot
    plt.savefig("anova_boxplot.png")
    print("\n‚úÖ Boxplot saved to 'anova_boxplot.png'")
    plt.show()

if __name__ == "__main__":
    main()

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy import stats

# ==============================================================================
# 1. Ï†úÏñ¥Í∏∞ Î∞è ÌôòÍ≤Ω ÌÅ¥ÎûòÏä§ Ï†ïÏùò (Core Logic)
# ==============================================================================
class FilteredPIDController:
    """ Standard PID with Low-Pass Filter on D-term """
    def __init__(self, kp, ki, kd, tau_f=0.1, out_min=0.0, out_max=100.0, dt=1.0):
        self.kp = kp
        self.ki = ki
        self.kd = kd
        self.tau_f = tau_f
        self.out_min = out_min
        self.out_max = out_max
        self.dt = dt
        self.integral = 0.0
        self.prev_error = 0.0
        self.d_term_filtered = 0.0
        self.prev_pv = None

    def update(self, sp, pv):
        error = sp - pv
        p_term = self.kp * error
        self.integral += error * self.dt
        self.integral = np.clip(self.integral, -100, 100)
        i_term = self.ki * self.integral

        if self.prev_pv is None: d_raw = 0.0
        else: d_raw = -(pv - self.prev_pv) / self.dt
        self.prev_pv = pv

        if self.tau_f > 0:
            alpha = self.tau_f / (self.tau_f + self.dt)
            self.d_term_filtered = alpha * self.d_term_filtered + (1 - alpha) * d_raw
        else:
            self.d_term_filtered = d_raw

        d_term = self.kd * self.d_term_filtered
        output = np.clip(p_term + i_term + d_term, self.out_min, self.out_max)
        return output

class ZGatedPIController:
    """ AEGIS Controller (User's Golden Parameters Applied) """
    def __init__(self, base_gain, ki, gain_max=10.0, target_noise=0.5,
                 p=1.5, gamma=0.01, anchor_decay=0.01, dt=1.0):
        self.base_gain = base_gain
        self.current_gain = base_gain
        self.ki = ki
        self.gain_max = gain_max
        self.target_noise = target_noise
        self.p = p
        self.gamma = gamma
        self.anchor_decay = anchor_decay
        self.dt = dt
        self.m_error = 0.0
        self.ep_energy = 0.0
        self.integral = 0.0
        self.beta = 0.9

    def update(self, sp, pv):
        error = sp - pv
        # Z-Gating Logic
        self.m_error = self.beta * self.m_error + (1 - self.beta) * error
        delta = error - self.m_error
        instability = abs(delta) ** self.p
        self.ep_energy = self.beta * self.ep_energy + (1 - self.beta) * instability
        sigma = (self.ep_energy + 1e-8) ** (1.0 / self.p)
        r = sigma / (self.target_noise + 1e-6)

        # Gain Dynamics
        da = -self.gamma * (r - 1.0) * self.current_gain
        da -= self.anchor_decay * (self.current_gain - self.base_gain)
        da *= self.dt
        self.current_gain = np.clip(self.current_gain + da, 0.1, self.gain_max)

        # PI Control
        p_term = self.current_gain * error
        self.integral += error * self.dt
        limit = 100.0 / (self.ki + 1e-6)
        self.integral = np.clip(self.integral, -limit, limit)
        i_term = self.ki * self.integral

        output = np.clip(p_term + i_term, 0.0, 100.0)
        return output, self.current_gain

class IndustrialHeater:
    def __init__(self, tau=20.0, gain=2.0, dt=1.0, initial_temp=20.0):
        self.tau = tau
        self.gain = gain
        self.dt = dt
        self.temp = initial_temp
    def step(self, u_input, external_noise=0.0, load_disturbance=0.0):
        d_temp = (self.gain * u_input - self.temp + load_disturbance) / self.tau * self.dt
        self.temp += d_temp
        return self.temp + external_noise

# ==============================================================================
# 2. Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ± Î∞è ÌÜµÍ≥Ñ Î∂ÑÏÑù Ìï®Ïàò
# ==============================================================================
def run_full_analysis(n_samples=30):
    print(f"üöÄ [Step 1] Î™¨ÌÖåÏπ¥Î•ºÎ°ú ÏãúÎÆ¨Î†àÏù¥ÏÖò ÏãúÏûë (N={n_samples})...")

    # Simulation Settings
    duration = 500
    sp_schedule = [50] * 150 + [80] * (duration - 150)

    # Controller Parameters (Golden Params)
    pid_params = dict(kp=3.0, ki=0.15, kd=5.0, tau_f=2.0)
    # User's Best Tuned Params
    aegis_params = dict(base_gain=5.0, ki=0.4, gamma=0.008, target_noise=0.8, gain_max=10.0)

    data = []

    for i in range(n_samples):
        seed = 42 + i
        np.random.seed(seed)

        # Noise & Disturbance
        noise_profile = np.random.normal(0, 0.8, size=duration)
        dist_profile = np.zeros(duration)
        dist_profile[300:450] = -30.0 # Severe Cold Draft

        # Init Objects
        pid = FilteredPIDController(dt=1.0, **pid_params)
        aegis = ZGatedPIController(dt=1.0, **aegis_params)
        proc_pid = IndustrialHeater()
        proc_aegis = IndustrialHeater()

        # Run Sim
        mv_pid_list, mv_aegis_list = [], []
        pv_pid_list, pv_aegis_list = [], []
        mv_pid, mv_aegis = 0.0, 0.0

        for t in range(duration):
            sp = sp_schedule[t]
            n = noise_profile[t]
            d = dist_profile[t]

            # PID
            pv_p = proc_pid.step(mv_pid, n, d)
            mv_pid = pid.update(sp, pv_p)

            # AEGIS
            pv_a = proc_aegis.step(mv_aegis, n, d)
            mv_aegis, _ = aegis.update(sp, pv_a)

            mv_pid_list.append(mv_pid)
            mv_aegis_list.append(mv_aegis)
            pv_pid_list.append(pv_p)
            pv_aegis_list.append(pv_a)

        # Metrics
        err_pid = np.array(sp_schedule) - np.array(pv_pid_list)
        err_aegis = np.array(sp_schedule) - np.array(pv_aegis_list)

        iae_pid = np.sum(np.abs(err_pid))
        iae_aegis = np.sum(np.abs(err_aegis))
        energy_pid = np.sum(np.array(mv_pid_list)**2)
        energy_aegis = np.sum(np.array(mv_aegis_list)**2)

        data.append({
            'seed': seed,
            'iae_pid': iae_pid,
            'iae_aegis': iae_aegis,
            'energy_pid': energy_pid,
            'energy_aegis': energy_aegis
        })

    df = pd.DataFrame(data)
    print(f"‚úÖ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ± ÏôÑÎ£å (Shape: {df.shape})")

    # ---------------------------------------------------------
    # [Step 2] ÌÜµÍ≥Ñ Î∂ÑÏÑù (Rigorous Statistics)
    # ---------------------------------------------------------
    print("\n" + "="*60)
    print("      üß™ ÏóÑÎ∞ÄÌïú ÌÜµÍ≥Ñ Í≤ÄÏ¶ù Î≥¥Í≥†ÏÑú (Rigorous Statistical Report)")
    print("="*60)

    # 1. ÎåÄÏùë ÌëúÎ≥∏ ÏÑ§Ï†ï
    diff = df['iae_pid'] - df['iae_aegis'] # Positive = AEGIS is better

    # 2. Ï†ïÍ∑úÏÑ± Í≤ÄÏ†ï (Shapiro-Wilk)
    shapiro_stat, shapiro_p = stats.shapiro(diff)
    print(f"[1] Ï†ïÍ∑úÏÑ± Í≤ÄÏ†ï (Shapiro-Wilk): p={shapiro_p:.4e}")
    normality = shapiro_p > 0.05

    # 3. Í∞ÄÏÑ§ Í≤ÄÏ†ï (Paired Test)
    if normality:
        test_name = "Paired t-test"
        stat, p_val = stats.ttest_rel(df['iae_pid'], df['iae_aegis'])
    else:
        test_name = "Wilcoxon Signed-Rank"
        stat, p_val = stats.wilcoxon(df['iae_pid'], df['iae_aegis'])

    print(f"[2] Í∞ÄÏÑ§ Í≤ÄÏ†ï ({test_name})")
    print(f"    * Statistic: {stat:.4f}")
    print(f"    * P-Value  : {p_val:.4e}")

    if p_val < 0.05:
        print("    >> ‚ú® Í≤∞Í≥º: ÌÜµÍ≥ÑÏ†ÅÏúºÎ°ú Îß§Ïö∞ Ïú†ÏùòÎØ∏Ìïú Ï∞®Ïù¥ ÏûàÏùå (Significant)")
    else:
        print("    >> ‚òÅÔ∏è Í≤∞Í≥º: Ïú†ÏùòÎØ∏Ìïú Ï∞®Ïù¥ ÏóÜÏùå")

    # 4. Ìö®Í≥º ÌÅ¨Í∏∞ (Cohen's d)
    mean_diff = np.mean(diff)
    std_diff = np.std(diff, ddof=1)
    cohens_d = mean_diff / std_diff
    print(f"[3] Ìö®Í≥º ÌÅ¨Í∏∞ (Cohen's d): {cohens_d:.4f}")
    if cohens_d > 0.8: print("    >> Ìï¥ÏÑù: 'Huge Effect' (ÏïïÎèÑÏ†Å Ï∞®Ïù¥)")

    # 5. Ï†úÏñ¥ ÏóêÎÑàÏßÄ Î∂ÑÏÑù
    mean_e_pid = df['energy_pid'].mean()
    mean_e_aegis = df['energy_aegis'].mean()
    e_ratio = mean_e_aegis / mean_e_pid
    print(f"[4] Ï†úÏñ¥ ÏóêÎÑàÏßÄ Ìö®Ïú®ÏÑ± (Energy Efficiency)")
    print(f"    * Energy Ratio (AEGIS/PID): {e_ratio:.2f}")
    if e_ratio < 1.0: print("    >> ‚úÖ AEGISÍ∞Ä ÏóêÎÑàÏßÄÎ•º Îçî Ï†ÅÍ≤å ÏÇ¨Ïö©Ìï® (Ìö®Ïú®Ï†Å)")
    elif e_ratio < 1.2: print("    >> ‚ö†Ô∏è AEGISÍ∞Ä ÏóêÎÑàÏßÄÎ•º ÏïΩÍ∞Ñ Îçî ÏÇ¨Ïö©Ìï® (ÌóàÏö© Î≤îÏúÑ)")
    else: print("    >> üö® AEGISÍ∞Ä Í≥ºÎèÑÌïú ÏóêÎÑàÏßÄÎ•º ÏÇ¨Ïö©Ìï®")

    # ---------------------------------------------------------
    # [Step 3] ÏãúÍ∞ÅÌôî (Visualization)
    # ---------------------------------------------------------
    plt.figure(figsize=(12, 5))

    # Plot 1: Paired Slope Chart
    plt.subplot(1, 2, 1)
    # Show first 15 lines only to avoid clutter
    for i in range(min(15, len(df))):
        plt.plot([1, 2], [df.loc[i, 'iae_pid'], df.loc[i, 'iae_aegis']],
                 'gray', alpha=0.5, linewidth=1)

    # Mean line
    plt.plot([1, 2], [df['iae_pid'].mean(), df['iae_aegis'].mean()],
             'r-o', linewidth=3, label='Average')

    plt.xticks([1, 2], ['Filtered PID', 'AEGIS'])
    plt.xlim(0.8, 2.2)
    plt.ylabel('IAE (Total Error)')
    plt.title('Paired Comparison (Lower is Better)')
    plt.grid(True, alpha=0.3)
    plt.legend()

    # Plot 2: Box Plot of Differences
    plt.subplot(1, 2, 2)
    plt.boxplot([df['iae_pid'], df['iae_aegis']], labels=['Filtered PID', 'AEGIS'], patch_artist=True)
    plt.title('Performance Distribution (N=30)')
    plt.ylabel('IAE')
    plt.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    run_full_analysis(n_samples=30)
